'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parsePropertyComponents = parsePropertyComponents;
exports.bytesSum = bytesSum;
exports.uint8Decoder = uint8Decoder;
exports.chunkArray = chunkArray;
exports.switchDecoder = switchDecoder;
exports.timestampDecoder = timestampDecoder;
exports.coordinatesDecoder = coordinatesDecoder;
exports.getRoundedIeee754ToBase10 = getRoundedIeee754ToBase10;
exports.getRoundedIeee754DoubleToBase10 = getRoundedIeee754DoubleToBase10;
exports.matrixZoneDecoder = matrixZoneDecoder;
exports.progressDecoder = progressDecoder;
exports.activeInactiveDecoder = activeInactiveDecoder;
exports.isArray = isArray;

var _encoding = require('./encoding');

function parsePropertyComponents(propertyComponentsData) {
  var componentCounter = 0;
  var componentBytes = {};

  while (componentCounter < propertyComponentsData.length) {
    var componentIdentifier = propertyComponentsData[componentCounter];
    var propertyComponentLength = bytesSum(propertyComponentsData.slice(componentCounter + 1, componentCounter + 3));

    var propertyComponentData = propertyComponentsData.slice(componentCounter + 3, componentCounter + 3 + propertyComponentLength);

    switch (componentIdentifier) {
      case _encoding.PROPERTY_DATA_ID:
        {
          componentBytes.data = propertyComponentData;
          break;
        }
      case _encoding.PROPERTY_TIMESTAMP_ID:
        {
          componentBytes.time = propertyComponentData;
          break;
        }
      case _encoding.PROPERTY_FAILURE_ID:
        {
          componentBytes.error = propertyComponentData;
          break;
        }
      default:
        break;
    }

    componentCounter += 3 + propertyComponentLength;
  }

  return componentBytes;
}

function bytesSum(bytes) {
  var hex = bytes.map(function (decimal) {
    return (0, _encoding.pad)(decimal.toString(16), 2);
  }).reduce(function (memo, i) {
    return memo + i;
  }, '');
  return Number('0x' + hex);
}

function uint8Decoder(bytes) {
  return (0, _encoding.uint8toInt8)(bytesSum(bytes));
}

function chunkArray(array) {
  var chunkCount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;

  var sets = [];
  var chunkSize = array.length / chunkCount;
  var i = 0;

  while (i < chunkCount) {
    sets[i] = array.splice(0, chunkSize);
    i++;
  }

  return sets;
}

function switchDecoder(options) {
  return function (bytes) {
    return bytes.length > 0 && bytes[0] in options ? options[bytes[0]] : null;
  };
}

function timestampDecoder(bytes) {
  return new Date(bytesSum(bytes));
}

function coordinatesDecoder(data) {
  return {
    latitude: getRoundedIeee754DoubleToBase10(6)(data.slice(0, data.length / 2)),
    longitude: getRoundedIeee754DoubleToBase10(6)(data.slice(data.length / 2))
  };
}

function getRoundedIeee754ToBase10(precision) {
  var precisionMultiplier = Math.pow(10, precision);

  return function () {
    var unrounded = _encoding.ieee754ToBase10.apply(undefined, arguments);
    return Math.round(unrounded * precisionMultiplier) / precisionMultiplier;
  };
}

function getRoundedIeee754DoubleToBase10(precision) {
  var precisionMultiplier = Math.pow(10, precision);

  return function () {
    var unrounded = _encoding.ieee754DoubleToBase10.apply(undefined, arguments);
    return Math.round(unrounded * precisionMultiplier) / precisionMultiplier;
  };
}

function matrixZoneDecoder(bytes) {
  return {
    rows: (bytes[0] & 0xf0) >> 4,
    columns: bytes[0] & 0x0f
  };
}

function progressDecoder(bytes) {
  return Math.round((0, _encoding.ieee754DoubleToBase10)(bytes) * 100) / 100;
}

function activeInactiveDecoder() {
  return switchDecoder({
    0x00: 'inactive',
    0x01: 'active'
  });
}

function isArray(value) {
  return value.BYTES_PER_ELEMENT && Object.prototype.toString.call(value.buffer) === '[object ArrayBuffer]' || Array.isArray(value);
}