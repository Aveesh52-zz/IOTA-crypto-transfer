import { ieee754DoubleToBase10, ieee754ToBase10, pad, uint8toInt8, PROPERTY_DATA_ID, PROPERTY_TIMESTAMP_ID, PROPERTY_FAILURE_ID } from './encoding';

export function parsePropertyComponents(propertyComponentsData) {
  var componentCounter = 0;
  var componentBytes = {};

  while (componentCounter < propertyComponentsData.length) {
    var componentIdentifier = propertyComponentsData[componentCounter];
    var propertyComponentLength = bytesSum(propertyComponentsData.slice(componentCounter + 1, componentCounter + 3));

    var propertyComponentData = propertyComponentsData.slice(componentCounter + 3, componentCounter + 3 + propertyComponentLength);

    switch (componentIdentifier) {
      case PROPERTY_DATA_ID:
        {
          componentBytes.data = propertyComponentData;
          break;
        }
      case PROPERTY_TIMESTAMP_ID:
        {
          componentBytes.time = propertyComponentData;
          break;
        }
      case PROPERTY_FAILURE_ID:
        {
          componentBytes.error = propertyComponentData;
          break;
        }
      default:
        break;
    }

    componentCounter += 3 + propertyComponentLength;
  }

  return componentBytes;
}

export function bytesSum(bytes) {
  var hex = bytes.map(function (decimal) {
    return pad(decimal.toString(16), 2);
  }).reduce(function (memo, i) {
    return memo + i;
  }, '');
  return Number('0x' + hex);
}

export function uint8Decoder(bytes) {
  return uint8toInt8(bytesSum(bytes));
}

export function chunkArray(array) {
  var chunkCount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;

  var sets = [];
  var chunkSize = array.length / chunkCount;
  var i = 0;

  while (i < chunkCount) {
    sets[i] = array.splice(0, chunkSize);
    i++;
  }

  return sets;
}

export function switchDecoder(options) {
  return function (bytes) {
    return bytes.length > 0 && bytes[0] in options ? options[bytes[0]] : null;
  };
}

export function timestampDecoder(bytes) {
  return new Date(bytesSum(bytes));
}

export function coordinatesDecoder(data) {
  return {
    latitude: getRoundedIeee754DoubleToBase10(6)(data.slice(0, data.length / 2)),
    longitude: getRoundedIeee754DoubleToBase10(6)(data.slice(data.length / 2))
  };
}

export function getRoundedIeee754ToBase10(precision) {
  var precisionMultiplier = Math.pow(10, precision);

  return function () {
    var unrounded = ieee754ToBase10.apply(undefined, arguments);
    return Math.round(unrounded * precisionMultiplier) / precisionMultiplier;
  };
}

export function getRoundedIeee754DoubleToBase10(precision) {
  var precisionMultiplier = Math.pow(10, precision);

  return function () {
    var unrounded = ieee754DoubleToBase10.apply(undefined, arguments);
    return Math.round(unrounded * precisionMultiplier) / precisionMultiplier;
  };
}

export function matrixZoneDecoder(bytes) {
  return {
    rows: (bytes[0] & 0xf0) >> 4,
    columns: bytes[0] & 0x0f
  };
}

export function progressDecoder(bytes) {
  return Math.round(ieee754DoubleToBase10(bytes) * 100) / 100;
}

export function activeInactiveDecoder() {
  return switchDecoder({
    0x00: 'inactive',
    0x01: 'active'
  });
}

export function isArray(value) {
  return value.BYTES_PER_ELEMENT && Object.prototype.toString.call(value.buffer) === '[object ArrayBuffer]' || Array.isArray(value);
}