var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

import PropertyResponse from '../PropertyResponse';
import PropertyDecoder from '../PropertyDecoder';
import { activeInactiveDecoder, getRoundedIeee754ToBase10, progressDecoder, switchDecoder } from '../helpers';
import { uint8toInt8 } from '../encoding';
import OptionalPropertyDecoder from '../OptionalPropertyDecoder';

var RaceResponse = function (_PropertyResponse) {
  _inherits(RaceResponse, _PropertyResponse);

  /**
   * @property {Object} accelerations (object '{type: (string), gForce: (number)}') Accelerations
   * @property {Number} understeering (number) Understeering percentage between 0-1
   * @property {Number} oversteering (number) Oversteering percentage between 0-1
   * @property {Number} gasPedalPosition (number) Gas pedal position percentage between 0-1
   * @property {Number} steeringAngle (number) Steering angle
   * @property {Number} brakePressure (number) Brake pressure
   * @property {Number} yawRate (number) Yaw rate
   * @property {Number} rearSuspensionSteering (number) Rear suspension steering
   * @property {String} electronicStabilityProgram (string 'active|inactive') Electronic stability program
   * @property {Object} brakeTorqueVectorings (object '{axle: (string), vectoring: (string)}') Brake torque vectorings
   * @property {String} gearMode (string 'manual|park|reverse|neutral|drive|low_gear|sport') Gear mode
   * @property {Number} selectedGear (number) Selected gear
   * @property {Number} brakePedalPosition (number) Brake pedal positioning percentage between 0-1
   * @property {String} brakePedalSwitch (string 'inactive|active') Brake pedal switch status
   * @property {String} clutchPedalSwitch (string 'inactive|active') Clutch pedal switch status
   * @property {String} acceleratorPedalIdleSwitch (string 'inactive|active') Accelerator pedal idle switch status
   * @property {String} acceleratorPedalKickdownSwitch (string 'inactive|active') Accelerator pedal kickdown switch status
   * @property {String} vehicleMoving (string 'not_moving|moving') Vehicle moving state
   *
   * @example RaceResponse
    {
      accelerations: [{
        value: {
          type: 'longitudinal_acceleration',
          gForce: 0,
        },
      }, {
        value: {
          type: 'lateral_acceleration',
          gForce: 0,
        },
      }, {
        value: {
          type: 'front_lateral_acceleration',
          gForce: 0,
        },
      }, {
        value: {
          type: 'rear_lateral_acceleration',
          gForce: 0,
        },
      }],
      understeering: { value: 0 },
      oversteering: { value: 0 },
      gasPedalPosition: { value: 0 },
      steeringAngle: { value: 0 },
      brakePressure: { value: 0 },
      yawRate: { value: 0 },
      rearSuspensionSteering: { value: 0 },
      electronicStabilityProgram: { value: 'inactive' },
      brakeTorqueVectorings: [{
        value: {
          axle: 'front_axle',
          vectoring: 'inactive',
        },
      }, {
        value: {
          axle: 'rear_axle',
          vectoring: 'inactive',
        },
      }],
      gearMode: { value: 'manual' },
      selectedGear: { value: 0 },
      brakePedalPosition: { value: 0 },
      brakePedalSwitch: { value: 'inactive' },
      clutchPedalSwitch: { value: 'inactive' },
      acceleratorPedalIdleSwitch: { value: 'inactive' },
      acceleratorPedalKickdownSwitch: { value: 'inactive' },
      vehicleMoving: { value: 'not_moving' },
    }
   */
  function RaceResponse(data, config) {
    _classCallCheck(this, RaceResponse);

    var _this = _possibleConstructorReturn(this, (RaceResponse.__proto__ || Object.getPrototypeOf(RaceResponse)).call(this));

    var properties = [new PropertyDecoder(0x01, 'accelerations').setOptionalSubProperties('type', [new OptionalPropertyDecoder(0x00, 'longitudinal_acceleration').setDecoder(_this.accelerationDecoder), new OptionalPropertyDecoder(0x01, 'lateral_acceleration').setDecoder(_this.accelerationDecoder), new OptionalPropertyDecoder(0x02, 'front_lateral_acceleration').setDecoder(_this.accelerationDecoder), new OptionalPropertyDecoder(0x03, 'rear_lateral_acceleration').setDecoder(_this.accelerationDecoder)]), new PropertyDecoder(0x02, 'understeering').setDecoder(progressDecoder), new PropertyDecoder(0x03, 'oversteering').setDecoder(progressDecoder), new PropertyDecoder(0x04, 'gasPedalPosition').setDecoder(progressDecoder), new PropertyDecoder(0x05, 'steeringAngle').setDecoder(uint8toInt8), new PropertyDecoder(0x06, 'brakePressure').setDecoder(getRoundedIeee754ToBase10(2)), new PropertyDecoder(0x07, 'yawRate').setDecoder(getRoundedIeee754ToBase10(2)), new PropertyDecoder(0x08, 'rearSuspensionSteering').setDecoder(uint8toInt8), new PropertyDecoder(0x09, 'electronicStabilityProgram').setDecoder(activeInactiveDecoder()), new PropertyDecoder(0x0a, 'brakeTorqueVectorings').setOptionalSubProperties('axle', [new OptionalPropertyDecoder(0x00, 'front_axle').setDecoder(_this.axleDecoder), new OptionalPropertyDecoder(0x01, 'rear_axle').setDecoder(_this.axleDecoder)]), new PropertyDecoder(0x0b, 'gearMode').setDecoder(switchDecoder({
      0x00: 'manual',
      0x01: 'park',
      0x02: 'reverse',
      0x03: 'neutral',
      0x04: 'drive',
      0x05: 'low_gear',
      0x06: 'sport'
    })), new PropertyDecoder(0x0c, 'selectedGear'), new PropertyDecoder(0x0d, 'brakePedalPosition').setDecoder(progressDecoder), new PropertyDecoder(0x0e, 'brakePedalSwitch').setDecoder(switchDecoder({
      0x00: 'inactive',
      0x01: 'active'
    })), new PropertyDecoder(0x0f, 'clutchPedalSwitch').setDecoder(switchDecoder({
      0x00: 'inactive',
      0x01: 'active'
    })), new PropertyDecoder(0x10, 'acceleratorPedalIdleSwitch').setDecoder(switchDecoder({
      0x00: 'inactive',
      0x01: 'active'
    })), new PropertyDecoder(0x11, 'acceleratorPedalKickdownSwitch').setDecoder(switchDecoder({
      0x00: 'inactive',
      0x01: 'active'
    })), new PropertyDecoder(0x12, 'vehicleMoving').setDecoder(switchDecoder({
      0x00: 'not_moving',
      0x01: 'moving'
    }))];

    _this.parse(data, properties, config);
    return _this;
  }

  _createClass(RaceResponse, [{
    key: 'axleDecoder',
    value: function axleDecoder(bytes) {
      return {
        vectoring: switchDecoder({
          0x00: 'inactive',
          0x01: 'active'
        })(bytes)
      };
    }
  }, {
    key: 'accelerationDecoder',
    value: function accelerationDecoder() {
      var decoder = getRoundedIeee754ToBase10(3);

      return {
        gForce: decoder.apply(undefined, arguments)
      };
    }
  }]);

  return RaceResponse;
}(PropertyResponse);

RaceResponse.identifier = [0x00, 0x57];
export default RaceResponse;