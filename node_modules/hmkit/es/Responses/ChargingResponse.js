var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

import PropertyResponse from '../PropertyResponse';
import PropertyDecoder from '../PropertyDecoder';
import OptionalPropertyDecoder from '../OptionalPropertyDecoder';
import { bytesSum, timestampDecoder, getRoundedIeee754ToBase10, switchDecoder, progressDecoder } from '../helpers';

var ChargingResponse = function (_PropertyResponse) {
  _inherits(ChargingResponse, _PropertyResponse);

  /**
   * @property {Number} estimatedRange (number) Estimated range in km
   * @property {Number} batteryLevel (number) Battery level 0..1 (0 = 0%, 1 = 100%)
   * @property {Number} batteryCurrentAC (number) Battery current (AC) in 4-bytes per IEEE 754
   * @property {Number} batteryCurrentDC (number) Battery current (DC) in 4-bytes per IEEE 754
   * @property {Number} chargerVoltageAC (number) Charger voltage (AC) in V
   * @property {Number} chargerVoltageDC (number) Charger voltage (DC) in V
   * @property {Number} chargeLimit (number) Charge limit 0..1 (0 = 0%, 1 = 100%)
   * @property {Number} timeToCompleteCharge (number) Time to complete charge in min
   * @property {Number} chargingRateKW (number) Charging rate (kW)
   * @property {String} chargePortState (string: 'closed|open') Charge port state
   * @property {String} chargeMode (string: 'immediate|timer_based|inductive') Charge mode
   * @property {Number} maxChargingCurrent (number) Maximum charging current in 4-bytes per IEEE 754
   * @property {String} plugType (string: 'type_1|type_2|ccs|chademo') Plug state
   * @property {String} chargingWindowChosen (string: 'not_chosen|chosen') Charging window chosen
   * @property {Array} departureTimes (array) Departure times [{ activeState: (boolean), hour: (number), minute: (number)}]
   * @property {Array} reductionTimes (array) Reduction of charging-current times [{ startStop: (string), hour: (number), minute: (number) }]
   * @property {Number} batteryTemperature (number) Battery temperature in Celsius in 4-bytes per IEEE 754
   * @property {Array} timers (array) Charging timers [{ timerType: (string), time: (date) }]
   * @property {String} pluggedIn (string) Plugged in
   * @property {String} activeState (string: 'not_charging | charging | charging_complete | initialising | charging_paused | charging_error') Charging state
   * @example ChargingResponse
    {
      estimatedRange: { value: 30 },
      batteryLevel: { value: 0.8 },
      batteryCurrentAC: { value: -0.6 },
      batteryCurrentDC: { value: -0.6 },
      chargerVoltageAC: { value: 0 },
      chargerVoltageDC: { value: 0 },
      chargeLimit: { value: 100 },
      timeToCompleteCharge: { value: 0 },
      chargingRateKW: { value: 0 },
      chargePortState: { value: 'closed' },
      chargeMode: { value: 'immediate' },
      maxChargingCurrent: { value: 25 },
      plugType: { value: 'type_2' },
      chargingWindowChosen: { value: 'not_chosen' },
      departureTimes: [{
        value: {
          activeState: 'inactive',
          hour: 13,
          minute: 51
        }
      }],
      reductionTimes: [{
        value: {
          startStop: 'start',
          hour: 2,
          minute: 5
        }
      }],
      batteryTemperature: { value: 38.4 },
      timers: [{
        value: {
          timerType: 'preferred_start_time',
          time: '2018-02-11T12:13:00.000Z',
        },
      }, {
        value: {
          timerType: 'preferred_end_time',
          time: '2018-02-11T12:14:00.000Z',
        },
      }, {
        value: {
          timerType: 'departure_time',
          time: '2018-02-10T13:45:33.157Z',
        },
      }],
      pluggedIn: { value: 'disconnected' },
      activeState: { value: 'not_charging' },
    }
   */

  function ChargingResponse(data, config) {
    _classCallCheck(this, ChargingResponse);

    var _this = _possibleConstructorReturn(this, (ChargingResponse.__proto__ || Object.getPrototypeOf(ChargingResponse)).call(this));

    var properties = [new PropertyDecoder(0x02, 'estimatedRange').setDecoder(bytesSum), new PropertyDecoder(0x03, 'batteryLevel').setDecoder(progressDecoder), new PropertyDecoder(0x04, 'batteryCurrentAC').setDecoder(getRoundedIeee754ToBase10(2)), new PropertyDecoder(0x05, 'batteryCurrentDC').setDecoder(getRoundedIeee754ToBase10(2)), new PropertyDecoder(0x06, 'chargerVoltageAC').setDecoder(getRoundedIeee754ToBase10(2)), new PropertyDecoder(0x07, 'chargerVoltageDC').setDecoder(getRoundedIeee754ToBase10(2)), new PropertyDecoder(0x08, 'chargeLimit').setDecoder(progressDecoder), new PropertyDecoder(0x09, 'timeToCompleteCharge').setDecoder(bytesSum), new PropertyDecoder(0x0a, 'chargingRateKW').setDecoder(getRoundedIeee754ToBase10(2)), new PropertyDecoder(0x0b, 'chargePortState').setDecoder(switchDecoder({
      0x00: 'closed',
      0x01: 'open'
    })), new PropertyDecoder(0x0c, 'chargeMode').setDecoder(switchDecoder({
      0x00: 'immediate',
      0x01: 'timer_based',
      0x02: 'inductive'
    })), new PropertyDecoder(0x0e, 'maxChargingCurrent').setDecoder(getRoundedIeee754ToBase10(2)), new PropertyDecoder(0x0f, 'plugType').setDecoder(switchDecoder({
      0x00: 'type_1',
      0x01: 'type_2',
      0x02: 'ccs',
      0x03: 'chademo'
    })), new PropertyDecoder(0x10, 'chargingWindowChosen').setDecoder(switchDecoder({
      0x00: 'not_chosen',
      0x01: 'chosen'
    })), new PropertyDecoder(0x11, 'departureTimes').array().setDecoder(_this.departureTimeDecoder), new PropertyDecoder(0x13, 'reductionTimes').array().setDecoder(_this.reductionTimeDecoder), new PropertyDecoder(0x14, 'batteryTemperature').setDecoder(getRoundedIeee754ToBase10(2)), new PropertyDecoder(0x15, 'timers').setOptionalSubProperties('timerType', [new OptionalPropertyDecoder(0x00, 'preferred_start_time').setDecoder(_this.timerTimeDecoder), new OptionalPropertyDecoder(0x01, 'preferred_end_time').setDecoder(_this.timerTimeDecoder), new OptionalPropertyDecoder(0x02, 'departure_time').setDecoder(_this.timerTimeDecoder)]), new PropertyDecoder(0x16, 'pluggedIn').setDecoder(switchDecoder({
      0x00: 'disconnected',
      0x01: 'plugged_in'
    })), new PropertyDecoder(0x17, 'activeState').setDecoder(switchDecoder({
      0x00: 'not_charging',
      0x01: 'charging',
      0x02: 'charging_complete',
      0x03: 'initialising',
      0x04: 'charging_paused',
      0x05: 'charging_error'
    }))];

    _this.parse(data, properties, config);
    return _this;
  }

  _createClass(ChargingResponse, [{
    key: 'timerTimeDecoder',
    value: function timerTimeDecoder() {
      return {
        time: timestampDecoder.apply(undefined, arguments)
      };
    }
  }, {
    key: 'departureTimeDecoder',
    value: function departureTimeDecoder(data) {
      return {
        activeState: { 0x00: 'inactive', 0x01: 'active' }[data[0]],
        hour: data[1],
        minute: data[2]
      };
    }
  }, {
    key: 'reductionTimeDecoder',
    value: function reductionTimeDecoder(data) {
      return {
        startStop: {
          0x00: 'start',
          0x01: 'stop',
          0x02: 'reset'
        }[data[0]],
        hour: data[1],
        minute: data[2]
      };
    }
  }]);

  return ChargingResponse;
}(PropertyResponse);

ChargingResponse.identifier = [0x00, 0x23];
export default ChargingResponse;