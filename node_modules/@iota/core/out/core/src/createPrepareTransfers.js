"use strict";
var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
exports.__esModule = true;
var Promise = require("bluebird");
var converter_1 = require("@iota/converter");
var bundle_1 = require("@iota/bundle");
var checksum_1 = require("@iota/checksum");
var signing_1 = require("@iota/signing");
var transaction_converter_1 = require("@iota/transaction-converter");
var errors = require("../../errors");
var guards_1 = require("../../guards");
var types_1 = require("../../types");
var utils_1 = require("../../utils");
var _1 = require("./");
var hmac_1 = require("./hmac");
var HASH_LENGTH = 81;
var SIGNATURE_MESSAGE_FRAGMENT_LENGTH = 2187;
var KEY_FRAGMENT_LENGTH = 6561;
var NULL_HASH_TRYTES = '9'.repeat(HASH_LENGTH);
var SECURITY_LEVEL = 2;
var defaults = {
    inputs: [],
    address: undefined,
    remainderAddress: undefined,
    security: 2,
    hmacKey: undefined
};
exports.getPrepareTransfersOptions = function (options) { return (__assign({}, types_1.getOptionsWithDefaults(defaults)(options), { remainderAddress: options.address || options.remainderAddress || undefined })); };
/**
 * Create a [`prepareTransfers`]{@link #module_core.prepareTransfers} function by passing an optional newtowrk `provider`.
 * It is possible to prepare and sign transactions offline, by omitting the provider option.
 *
 * @method createPrepareTransfers
 *
 * @memberof module:core
 *
 * @param {Provider} [provider] - Optional network provider to fetch inputs and remainder address.
 * In case this is omitted, proper input objects and remainder should be passed
 * to [`prepareTransfers`]{@link #module_core.prepareTransfers}, if required.
 *
 * @return {Function} {@link #module_core.prepareTransfers `prepareTransfers`}
 */
exports.createPrepareTransfers = function (provider, now, caller) {
    if (now === void 0) { now = function () { return Date.now(); }; }
    var addInputs = exports.createAddInputs(provider);
    var addRemainder = exports.createAddRemainder(provider);
    /**
     * Prepares the transaction trytes by generating a bundle, filling in transfers and inputs,
     * adding remainder and signing. It can be used to generate and sign bundles either online or offline.
     * For offline usage, please see [`createPrepareTransfers`]{@link #module_core.createPrepareTransfers}
     * which creates a `prepareTransfers` without a network provider.
     *
     * @method prepareTransfers
     *
     * @memberof module:core
     *
     * @param {string} seed
     *
     * @param {object} transfers
     *
     * @param {object} [options]
     * @param {Input[]} [options.inputs] Inputs used for signing. Needs to have correct security, keyIndex and address value
     * @param {Hash} [options.inputs[].address] Input address trytes
     * @param {number} [options.inputs[].keyIndex] Key index at which address was generated
     * @param {number} [options.inputs[].security = 2] Security level
     * @param {number} [options.inputs[].balance] Balance in iotas
     * @param {Hash} [options.address] Remainder address
     * @param {Number} [options.security] Security level to be used for getting inputs and reminder address
     * @property {Hash} [options.hmacKey] HMAC key used for attaching an HMAC
     *
     * @param {function} [callback] Optional callback
     *
     * @return {Promise}
     * @fulfil {array} trytes Returns bundle trytes
     * @reject {Error}
     * - `INVALID_SEED`
     * - `INVALID_TRANSFER_ARRAY`
     * - `INVALID_INPUT`
     * - `INVALID_REMAINDER_ADDRESS`
     * - `INSUFFICIENT_BALANCE`
     * - `NO_INPUTS`
     * - `SENDING_BACK_TO_INPUTS`
     * - Fetch error, if connected to network
     */
    return function prepareTransfers(seed, transfers, options, callback) {
        if (options === void 0) { options = {}; }
        if (caller !== 'lib') {
            if (options.address) {
                /* tslint:disable-next-line:no-console */
                console.warn('`options.address` is deprecated and will be removed in v2.0.0. Use `options.remainderAddress` instead.');
            }
            if (guards_1.isTrytes(seed) && seed.length < 81) {
                /* tslint:disable-next-line:no-console */
                console.warn('WARNING: Seeds with less length than 81 trytes are not secure! Use a random, 81-trytes long seed!');
            }
        }
        var props = Promise.resolve(exports.validatePrepareTransfers(__assign({ transactions: [], trytes: [], seed: seed, transfers: transfers.map(function (transfer) { return (__assign({}, transfer, { message: transfer.message || '', tag: transfer.tag || '' })); }), timestamp: Math.floor((typeof now === 'function' ? now() : Date.now()) / 1000) }, exports.getPrepareTransfersOptions(options))));
        return utils_1.asyncPipe(exports.addHMACPlaceholder, exports.addTransfers, addInputs, addRemainder, exports.verifyNotSendingToInputs, exports.finalize, exports.addSignatures, exports.addHMAC, exports.asTransactionTrytes)(props)
            .then(function (_a) {
            var trytes = _a.trytes;
            return trytes;
        })
            .asCallback(callback);
    };
};
exports.validatePrepareTransfers = function (props) {
    var seed = props.seed, transfers = props.transfers, inputs = props.inputs, security = props.security;
    var remainderAddress = props.address || props.remainderAddress;
    guards_1.validate(guards_1.seedValidator(seed), guards_1.securityLevelValidator(security), guards_1.arrayValidator(guards_1.transferValidator)(transfers), !!remainderAddress && guards_1.remainderAddressValidator(remainderAddress), inputs.length > 0 && guards_1.arrayValidator(guards_1.inputValidator)(inputs));
    return props;
};
exports.addHMACPlaceholder = function (props) {
    var hmacKey = props.hmacKey, transfers = props.transfers;
    return hmacKey
        ? __assign({}, props, { transfers: transfers.map(function (transfer, i) {
                return transfer.value > 0
                    ? __assign({}, transfer, { message: NULL_HASH_TRYTES + transfer.message }) : transfer;
            }) }) : props;
};
exports.addTransfers = function (props) {
    var transactions = props.transactions, transfers = props.transfers, timestamp = props.timestamp;
    return __assign({}, props, { transactions: transfers.reduce(function (acc, _a) {
            var address = _a.address, value = _a.value, tag = _a.tag, message = _a.message;
            var length = Math.ceil(((message || '').length || 1) / SIGNATURE_MESSAGE_FRAGMENT_LENGTH);
            return bundle_1.addEntry(acc, {
                address: checksum_1.removeChecksum(address),
                value: value,
                tag: tag,
                timestamp: timestamp,
                length: length,
                signatureMessageFragments: Array(length)
                    .fill('')
                    .map(function (_, i) {
                    return (message || '').slice(i * SIGNATURE_MESSAGE_FRAGMENT_LENGTH, (i + 1) * SIGNATURE_MESSAGE_FRAGMENT_LENGTH);
                })
            });
        }, transactions) });
};
exports.createAddInputs = function (provider) {
    var getInputs = provider ? _1.createGetInputs(provider) : undefined;
    return function (props) {
        var transactions = props.transactions, transfers = props.transfers, inputs = props.inputs, timestamp = props.timestamp, seed = props.seed, security = props.security;
        var threshold = transfers.reduce(function (sum, _a) {
            var value = _a.value;
            return (sum += value);
        }, 0);
        if (threshold === 0) {
            return Promise.resolve(props);
        }
        if (inputs.length && threshold > inputs.reduce(function (acc, input) { return (acc += input.balance); }, 0)) {
            throw new Error(inputs.length ? errors.INSUFFICIENT_BALANCE : errors.NO_INPUTS);
        }
        return (!getInputs || inputs.length
            ? Promise.resolve(inputs)
            : getInputs(seed, { security: security, threshold: threshold }).then(function (response) { return response.inputs; })).then(function (res) { return (__assign({}, props, { inputs: res, transactions: res.reduce(function (acc, input) {
                return bundle_1.addEntry(acc, {
                    length: input.security,
                    address: checksum_1.removeChecksum(input.address),
                    value: -input.balance,
                    timestamp: timestamp || Math.floor(Date.now() / 1000)
                });
            }, transactions) })); });
    };
};
exports.createAddRemainder = function (provider) {
    var getNewAddress = provider ? _1.createGetNewAddress(provider, 'lib') : undefined;
    return function (props) {
        var transactions = props.transactions, remainderAddress = props.remainderAddress, seed = props.seed, security = props.security, inputs = props.inputs, timestamp = props.timestamp;
        // Values of transactions in the bundle should sum up to 0.
        var value = transactions.reduce(function (acc, transaction) { return (acc += transaction.value); }, 0);
        // Value > 0 indicates insufficient balance in inputs.
        if (value > 0) {
            throw new Error(errors.INSUFFICIENT_BALANCE);
        }
        // If value is already zero no remainder is required
        if (value === 0) {
            return props;
        }
        if (!provider && !remainderAddress) {
            throw new Error(errors.INVALID_REMAINDER_ADDRESS);
        }
        return (remainderAddress
            ? Promise.resolve(remainderAddress)
            : getNewAddress(seed, {
                index: exports.getRemainderAddressStartIndex(inputs),
                security: security
            })).then(function (address) {
            address = types_1.asArray(address)[0];
            return __assign({}, props, { remainderAddress: address, transactions: bundle_1.addEntry(transactions, {
                    length: 1,
                    address: address,
                    value: Math.abs(value),
                    timestamp: timestamp || Math.floor(Date.now() / 1000)
                }) });
        });
    };
};
exports.getRemainderAddressStartIndex = function (inputs) {
    return inputs.slice().sort(function (a, b) { return b.keyIndex - a.keyIndex; })[0].keyIndex + 1;
};
exports.verifyNotSendingToInputs = function (props) {
    var transactions = props.transactions;
    var isSendingToInputs = transactions
        .filter(function (_a) {
        var value = _a.value;
        return value < 0;
    })
        .some(function (output) { return transactions.findIndex(function (input) { return input.value > 0 && input.address === output.address; }) > -1; });
    if (isSendingToInputs) {
        throw new Error(errors.SENDING_BACK_TO_INPUTS);
    }
    return props;
};
exports.finalize = function (props) { return (__assign({}, props, { transactions: bundle_1.finalizeBundle(props.transactions) })); };
exports.addSignatures = function (props) {
    var transactions = props.transactions, inputs = props.inputs, seed = props.seed;
    var normalizedBundle = signing_1.normalizedBundleHash(transactions[0].bundle);
    return __assign({}, props, { transactions: bundle_1.addTrytes(transactions, inputs.reduce(function (acc, _a) {
            var keyIndex = _a.keyIndex, security = _a.security;
            var keyTrits = signing_1.key(signing_1.subseed(converter_1.trits(seed), keyIndex), security || SECURITY_LEVEL);
            return acc.concat(Array(security)
                .fill(null)
                .map(function (_, i) {
                return converter_1.trytes(signing_1.signatureFragment(normalizedBundle.slice(i * HASH_LENGTH / 3, (i + 1) * HASH_LENGTH / 3), keyTrits.slice(i * KEY_FRAGMENT_LENGTH, (i + 1) * KEY_FRAGMENT_LENGTH)));
            }));
        }, []), transactions.findIndex(function (_a) {
            var value = _a.value;
            return value < 0;
        })) });
};
exports.addHMAC = function (props) {
    var hmacKey = props.hmacKey, transactions = props.transactions;
    return hmacKey ? __assign({}, props, { transactions: hmac_1["default"](transactions, converter_1.trits(hmacKey)) }) : props;
};
exports.asTransactionTrytes = function (props) { return (__assign({}, props, { trytes: transaction_converter_1.asFinalTransactionTrytes(props.transactions) })); };
//# sourceMappingURL=createPrepareTransfers.js.map