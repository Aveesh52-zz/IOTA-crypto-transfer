"use strict";
/** @module bundle-validator */
var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
exports.__esModule = true;
var converter_1 = require("@iota/converter");
var kerl_1 = require("@iota/kerl");
var signing_1 = require("@iota/signing");
var transaction_1 = require("@iota/transaction");
var transaction_converter_1 = require("@iota/transaction-converter");
var errors = require("../../errors");
var guards_1 = require("../../guards");
/**
 * Validates all signatures of a bundle.
 *
 * @method validateSignatures
 *
 * @param {Transaction[]} bundle
 *
 * @return {boolean}
 */
exports.validateBundleSignatures = function (bundle) {
    var signatures = bundle.slice().sort(function (a, b) { return a.currentIndex - b.currentIndex; }).reduce(function (acc, _a, i) {
        var address = _a.address, signatureMessageFragment = _a.signatureMessageFragment, value = _a.value;
        return value < 0
            ? __assign({}, acc, (_b = {}, _b[address] = [signatureMessageFragment], _b)) : value === 0 && acc.hasOwnProperty(address) && address === bundle[i - 1].address
            ? __assign({}, acc, (_c = {}, _c[address] = acc[address].concat(signatureMessageFragment), _c)) : acc;
        var _b, _c;
    }, {});
    return Object.keys(signatures).every(function (address) { return signing_1.validateSignatures(address, signatures[address], bundle[0].bundle); });
};
/**
 * Checks if a bundle is _syntactically_ valid.
 * Validates signatures and overall structure.
 *
 * @method isBundle
 *
 * @param {Transaction[]} bundle
 *
 * @returns {boolean}
 */
function isBundle(bundle) {
    if (!guards_1.isArray(transaction_1.isTransaction)(bundle)) {
        return false;
    }
    var totalSum = 0;
    var bundleHash = bundle[0].bundle;
    var kerl = new kerl_1["default"]();
    kerl.initialize();
    // Prepare for signature validation
    var signaturesToValidate = [];
    bundle.forEach(function (bundleTx, index) {
        totalSum += bundleTx.value;
        // currentIndex has to be equal to the index in the array
        if (bundleTx.currentIndex !== index) {
            return false;
        }
        // Get the transaction trytes
        var thisTxTrytes = transaction_converter_1.asTransactionTrytes(bundleTx);
        var thisTxTrits = converter_1.trits(thisTxTrytes.slice(2187, 2187 + 162));
        kerl.absorb(thisTxTrits, 0, thisTxTrits.length);
        // Check if input transaction
        if (bundleTx.value < 0) {
            var thisAddress = bundleTx.address;
            var newSignatureToValidate = {
                address: thisAddress,
                signatureFragments: Array(bundleTx.signatureMessageFragment)
            };
            // Find the subsequent txs with the remaining signature fragment
            for (var i = index; i < bundle.length - 1; i++) {
                var newBundleTx = bundle[i + 1];
                // Check if new tx is part of the signature fragment
                if (newBundleTx.address === thisAddress && newBundleTx.value === 0) {
                    newSignatureToValidate.signatureFragments.push(newBundleTx.signatureMessageFragment);
                }
            }
            signaturesToValidate.push(newSignatureToValidate);
        }
    });
    // Check for total sum, if not equal 0 return error
    if (totalSum !== 0) {
        return false;
    }
    // Prepare to absorb txs and get bundleHash
    var bundleFromTxs = new Int8Array(kerl_1["default"].HASH_LENGTH);
    // get the bundle hash from the bundle transactions
    kerl.squeeze(bundleFromTxs, 0, kerl_1["default"].HASH_LENGTH);
    var bundleHashFromTxs = converter_1.trytes(bundleFromTxs);
    // Check if bundle hash is the same as returned by tx object
    if (bundleHashFromTxs !== bundleHash) {
        return false;
    }
    // Last tx in the bundle should have currentIndex === lastIndex
    if (bundle[bundle.length - 1].currentIndex !== bundle[bundle.length - 1].lastIndex) {
        return false;
    }
    return exports.validateBundleSignatures(bundle);
}
exports["default"] = isBundle;
exports.bundleValidator = function (bundle) { return [bundle, isBundle, errors.INVALID_BUNDLE]; };
//# sourceMappingURL=index.js.map