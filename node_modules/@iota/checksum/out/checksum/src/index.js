"use strict";
/** @module checksum */
exports.__esModule = true;
var converter_1 = require("@iota/converter");
var kerl_1 = require("@iota/kerl");
var errors_1 = require("../../errors");
var guards_1 = require("../../guards");
var types_1 = require("../../types");
exports.errors = {
    INVALID_ADDRESS: errors_1.INVALID_ADDRESS,
    INVALID_CHECKSUM: errors_1.INVALID_CHECKSUM,
    INVALID_TRYTES: errors_1.INVALID_TRYTES,
    INVALID_CHECKSUM_LENGTH: 'Invalid checksum length'
};
var HASH_TRYTES_LENGTH = 81;
var ADDRESS_CHECKSUM_TRYTES_LENGTH = 9;
var ADDRESS_WITH_CHECKSUM_TRYTES_LENGTH = HASH_TRYTES_LENGTH + ADDRESS_CHECKSUM_TRYTES_LENGTH;
var MIN_CHECKSUM_TRYTES_LENGTH = 3;
function addChecksum(input, checksumLength, isAddress) {
    if (checksumLength === void 0) { checksumLength = ADDRESS_CHECKSUM_TRYTES_LENGTH; }
    if (isAddress === void 0) { isAddress = true; }
    var withChecksum = types_1.asArray(input).map(function (inputTrytes) {
        if (!guards_1.isTrytes(inputTrytes)) {
            throw new Error(exports.errors.INVALID_TRYTES);
        }
        if (isAddress && inputTrytes.length !== HASH_TRYTES_LENGTH) {
            if (inputTrytes.length === ADDRESS_WITH_CHECKSUM_TRYTES_LENGTH) {
                return inputTrytes;
            }
            throw new Error(exports.errors.INVALID_ADDRESS);
        }
        if (!Number.isInteger(checksumLength) ||
            checksumLength < MIN_CHECKSUM_TRYTES_LENGTH ||
            (isAddress && checksumLength !== ADDRESS_CHECKSUM_TRYTES_LENGTH)) {
            throw new Error(exports.errors.INVALID_CHECKSUM_LENGTH);
        }
        var paddedInputTrytes = inputTrytes;
        while (paddedInputTrytes.length % HASH_TRYTES_LENGTH !== 0) {
            paddedInputTrytes += '9';
        }
        var inputTrits = converter_1.trits(paddedInputTrytes);
        var checksumTrits = new Int8Array(kerl_1["default"].HASH_LENGTH);
        var kerl = new kerl_1["default"]();
        kerl.initialize();
        kerl.absorb(inputTrits, 0, inputTrits.length);
        kerl.squeeze(checksumTrits, 0, kerl_1["default"].HASH_LENGTH);
        return inputTrytes.concat(converter_1.trytes(checksumTrits.slice(243 - checksumLength * 3, 243)));
    });
    return Array.isArray(input) ? withChecksum : withChecksum[0];
}
exports.addChecksum = addChecksum;
function removeChecksum(input) {
    var tryteArray = types_1.asArray(input);
    if (tryteArray.length === 0 ||
        !tryteArray.every(function (t) { return guards_1.isTrytes(t, HASH_TRYTES_LENGTH) || guards_1.isTrytes(t, ADDRESS_WITH_CHECKSUM_TRYTES_LENGTH); })) {
        throw new Error(exports.errors.INVALID_ADDRESS);
    }
    var noChecksum = tryteArray.map(function (inputTrytes) { return inputTrytes.slice(0, HASH_TRYTES_LENGTH); });
    // return either string or the list
    return Array.isArray(input) ? noChecksum : noChecksum[0];
}
exports.removeChecksum = removeChecksum;
/**
 * Validates the checksum of the given address trytes.
 *
 * @method isValidChecksum
 *
 * @param {string} addressWithChecksum
 *
 * @return {boolean}
 */
exports.isValidChecksum = function (addressWithChecksum) {
    return addressWithChecksum === addChecksum(removeChecksum(addressWithChecksum));
};
//# sourceMappingURL=index.js.map